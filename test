diff --git a/README.md b/README.md
index a5f6d8d..41adbad 100644
--- a/README.md
+++ b/README.md
@@ -21,10 +21,12 @@ Before cloning, ensure you have the necessary system packages installed.
 Requires `base-devel` for build tools, plus QEMU and OVMF for testing.
 
 ```bash
-pacman -S base-devel git python nasm gcc make qemu-full edk2-ovmf
+pacman -S base-devel git python nasm gcc make gptfdisk mtools qemu-full edk2-ovmf
 ```
 
 ### FreeBSD
+**Temporarily unavailable for FreeBSD users**
+
 Requires `gcc` and `binutils` (for EDK2 GCC5 toolchain compatibility), `gmake`, and virtualization tools.
 
 #### Option 1: Using Binary Packages (Recommended)
diff --git a/scripts/run_qemu.sh b/scripts/run_qemu.sh
index e2acf57..377d5ae 100755
--- a/scripts/run_qemu.sh
+++ b/scripts/run_qemu.sh
@@ -4,19 +4,32 @@
 # Configuration
 # ==============================================================================
 
+PROJECT_ROOT="$(pwd)"
+BIN_DIR="${PROJECT_ROOT}/bin"
+
 # Arch Linux standard paths for UEFI Firmware (OVMF)
 # Note: Arch now uses 4MB images by default (.4m.fd)
 OVMF_CODE="/usr/share/edk2/x64/OVMF_CODE.4m.fd"
 OVMF_VARS="/usr/share/edk2/x64/OVMF_VARS.4m.fd"
 
 # S4 image generated by generator/main.py
-S4IMG_FILE="./bin/s4_image.bin"
+S4IMG_FILE="${BIN_DIR}/s4_image.bin"
 
 # The target UEFI application built by 'build_uefi.sh'
-EFI_FILE="./bin/Activator.efi"
+EFI_FILE="${BIN_DIR}/Activator.efi"
+
+# Output Disk Image
+DISK_IMG="${BIN_DIR}/disk.img"
+
+# Partition Layout Constants
+# Align everything to 1MB (2048 sectors * 512 bytes) for simplicity
+SECTOR_SIZE=512
+ESP_START_SECTOR=2048             # 1MB
+ESP_SIZE_MB=64
+ESP_SIZE_SECTORS=$((ESP_SIZE_MB * 1024 * 1024 / SECTOR_SIZE))
 
-# Temporary directory to simulate the EFI System Partition (ESP)
-ESP_DIR="./bin/esp"
+# Swap starts right after ESP
+SWAP_START_SECTOR=$((ESP_START_SECTOR + ESP_SIZE_SECTORS))
 
 # ==============================================================================
 # Pre-flight Checks
@@ -40,26 +53,77 @@ if [ ! -f "$OVMF_CODE" ]; then
     exit 1
 fi
 
+if ! command -v sgdisk &> /dev/null; then
+    echo "Error: 'sgdisk' not found. Please install 'gptfdisk'."
+    echo "  sudo pacman -S gptfdisk"
+    exit 1
+fi
+
+if ! command -v mformat &> /dev/null; then
+    echo "Error: 'mtools' not found. Please install it."
+    echo "  sudo pacman -S mtools"
+    exit 1
+fi
+
+mkdir -p "$BIN_DIR"
+
 # ==============================================================================
-# ESP Setup
+# Disk Image Creation
 # ==============================================================================
 
-# Create the standard UEFI directory structure.
-# /EFI/BOOT is the default search path for removable media.
-mkdir -p "$ESP_DIR/EFI/BOOT"
+echo "========================================"
+echo "Fabricating Disk Image ($DISK_IMG)..."
+
+# 1. Create a blank 512MB disk image
+# We use dd to create a sparse file quickly
+dd if=/dev/zero of="$DISK_IMG" bs=1M count=512 status=none
+
+# 2. Partitioning with sgdisk (GPT)
+# -o: Clear partition table
+# -n: New partition (num:start:end)
+# -t: Type code (EF00 = EFI System, A502 = FreeBSD Swap)
+# -c: Partition name
+sgdisk -o \
+    -n 1:$ESP_START_SECTOR:+$((ESP_SIZE_MB))M -t 1:EF00 -c 1:"EFI System" \
+    -n 2:$SWAP_START_SECTOR:0              -t 2:A502 -c 2:"FreeBSD Swap" \
+    "$DISK_IMG" > /dev/null
+
+echo "  -> GPT Table created."
+echo "     P1: ESP  (Start: ${ESP_START_SECTOR}s, Size: ${ESP_SIZE_MB}MB)"
+echo "     P2: SWAP (Start: ${SWAP_START_SECTOR}s, Type: FreeBSD Swap)"
+
+# ==============================================================================
+# Partition 1: EFI System Partition (FAT32)
+# ==============================================================================
+# Calculate byte offset for mtools
+# mtools allow accessing a partition inside an image using '@@offset' syntax
+ESP_OFFSET_BYTES=$((ESP_START_SECTOR * SECTOR_SIZE))
+
+# 1. Format P1 as FAT32
+mformat -i "${DISK_IMG}@@${ESP_OFFSET_BYTES}" -F ::
+
+# 2. Create Directory Structure
+mmd -i "${DISK_IMG}@@${ESP_OFFSET_BYTES}" ::/EFI
+mmd -i "${DISK_IMG}@@${ESP_OFFSET_BYTES}" ::/EFI/BOOT
+
+# 3. Install Activator as Bootloader
+mcopy -i "${DISK_IMG}@@${ESP_OFFSET_BYTES}" "$EFI_FILE" ::/EFI/BOOT/BOOTX64.EFI
+
+echo "  -> Activator installed to ESP."
+
+# ==============================================================================
+# Partition 2: FreeBSD Swap (Raw Write)
+# ==============================================================================
 
-# Copy the activator and rename it to BOOTX64.EFI.
-# This forces the UEFI firmware to load it automatically on boot
-# without needing a boot manager entry.
-cp "$EFI_FILE" "$ESP_DIR/EFI/BOOT/BOOTX64.EFI"
+# We write the S4 image directly to the start of the Swap partition.
+# This aligns with our C code which reads from LBA 0 relative to the partition handle.
+echo "  -> Writing S4 Image to Swap Partition..."
 
-# Copy the S4 image to the EFI system partition
-cp "$S4IMG_FILE" "$ESP_DIR/s4_image.bin"
+dd if="$S4IMG_FILE" of="$DISK_IMG" \
+   bs="$SECTOR_SIZE" seek="$SWAP_START_SECTOR" \
+   conv=notrunc status=none
 
 echo "========================================"
-echo "Preparing Virtual EFI System Partition at $ESP_DIR"
-echo "Activator installed as /EFI/BOOT/BOOTX64.EFI"
-echo "S4 image installed as /s4_image.bin"
 echo "Starting QEMU..."
 echo "========================================"
 
@@ -67,22 +131,14 @@ echo "========================================"
 # QEMU Execution
 # ==============================================================================
 
-# Explanation of flags:
-# -enable-kvm : Use hardware virtualization (faster)
-# -m 512M     : Allocate 512MB RAM
-# -drive ...  : Load the OVMF firmware code and variables via pflash
-#               (readonly=on for vars to prevent QEMU from trying to write back to /usr/share)
-# -drive ...  : Mount the $ESP_DIR directory as a virtual FAT32 USB drive
-# -serial ... : Redirect virtual COM1 to host terminal (to see "Hi" from trampoline)
-# -net none   : Disable networking to reduce noise
-# -nographic  : Optional flag. If enabled, output goes to terminal.
-#               For now, we use the GUI window to see the TianoCore logo.
+# -drive file="$DISK_IMG",format=raw: Connect our GPT disk image as a raw hard drive
+# Note: We removed the 'fat:rw:...' argument.
 
 qemu-system-x86_64 \
     -enable-kvm \
     -m 512M \
     -drive if=pflash,format=raw,readonly=on,file="$OVMF_CODE" \
     -drive if=pflash,format=raw,readonly=on,file="$OVMF_VARS" \
-    -drive format=raw,file=fat:rw:"$ESP_DIR" \
+    -drive file="$DISK_IMG",format=raw \
     -serial stdio \
     -net none
\ No newline at end of file
diff --git a/uefi/S4ActivatorPkg/Application/Activator/Activator.c b/uefi/S4ActivatorPkg/Application/Activator/Activator.c
index 0b5380a..1de0c7a 100644
--- a/uefi/S4ActivatorPkg/Application/Activator/Activator.c
+++ b/uefi/S4ActivatorPkg/Application/Activator/Activator.c
@@ -1,16 +1,24 @@
 #include <Uefi.h>
 #include <Library/UefiLib.h>
+#include <Library/BaseMemoryLib.h>
 #include <Library/UefiApplicationEntryPoint.h>
 #include <Library/UefiBootServicesTableLib.h>
 #include <Library/MemoryAllocationLib.h>
 #include <Protocol/LoadedImage.h>
 #include <Protocol/SimpleFileSystem.h>
+#include <Protocol/BlockIo.h>
+#include <Protocol/PartitionInfo.h>
 #include <Guid/FileInfo.h>
 
 #include "elf64.h"
 
 #define S4_IMAGE_NAME L"\\s4_image.bin"
 
+// FreeBSD Swap Partition GUID: 516e7cb5-6ecf-11d6-8ff8-00022d09712b
+EFI_GUID gFreeBSDSwapGuid = {
+    0x516e7cb5, 0x6ecf, 0x11d6, {0x8f, 0xf8, 0x00, 0x02, 0x2d, 0x09, 0x71, 0x2b}
+};
+
 VOID
 EFIAPI
 AsmTransferControl (
@@ -26,76 +34,109 @@ UefiMain (
   )
 {
     EFI_STATUS                         Status;
-    EFI_LOADED_IMAGE_PROTOCOL          *LoadedImage       = NULL;
-    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL    *FileSystem        = NULL;
-    EFI_FILE_PROTOCOL                  *Root              = NULL;
-    EFI_FILE_PROTOCOL                  *S4ImgFile         = NULL;
+    // EFI_LOADED_IMAGE_PROTOCOL          *LoadedImage       = NULL;
+    // EFI_SIMPLE_FILE_SYSTEM_PROTOCOL    *FileSystem        = NULL;
+    // EFI_FILE_PROTOCOL                  *Root              = NULL;
+    // EFI_FILE_PROTOCOL                  *S4ImgFile         = NULL;
+    UINTN                              HandleCount;
+    EFI_HANDLE                         *HandleBuffer      = NULL;
+    EFI_PARTITION_INFO_PROTOCOL        *PartInfo          = NULL;
+    EFI_BLOCK_IO_PROTOCOL              *BlkIO             = NULL;
+    EFI_BLOCK_IO_PROTOCOL              *SwapBlkIO         = NULL;
     Elf64_Ehdr                         Elf64Ehdr;
-    UINT16                             PhdrNum;
-    UINT16                             PhdrEntSize;
-    UINT64                             PhdrOffset;
     Elf64_Phdr                         *Elf64PhdrTable    = NULL;
-    UINTN                              ReadSize;
     EFI_PHYSICAL_ADDRESS               PcbPAddr           = 0;
     EFI_PHYSICAL_ADDRESS               TrampolinePAddr    = 0;
 
-    Print(L"[Activator] Locate Protocols...\n");
+    Print(L"[Activator] Locate swap partition handle...\n");
 
-    Status = gBS->HandleProtocol(
-        ImageHandle,
-        &gEfiLoadedImageProtocolGuid,
-        (VOID **)&LoadedImage
-    );
 
+    // ============================================================
+    // Locate FreeBSD swap partition BlockIOProtocol
+    // ============================================================
+    Status = gBS->LocateHandleBuffer(ByProtocol,
+                                     &gEfiBlockIoProtocolGuid,
+                                     NULL,
+                                     &HandleCount,
+                                     &HandleBuffer);
     if (EFI_ERROR(Status)) {
-      Print(L"Error: Cannot get LoadedImage protocol: %r\n", Status);
+      Print(L"Error: LocateHandleBuffer failed: %r\n", Status);
       goto ErrorExit;
     }
 
-    Status = gBS->HandleProtocol(
-        LoadedImage->DeviceHandle,
-        &gEfiSimpleFileSystemProtocolGuid,
-        (VOID **)&FileSystem
-    );
+    Print(L"[Debug] Found %d BlockIO handles\n", HandleCount);
 
-    if (EFI_ERROR(Status)) {
-      Print(L"Error: Cannot get SimpleFileSystem protocol: %r\n", Status);
-      goto ErrorExit;
+    for (UINTN i = 0; i < HandleCount; i++) {
+      Status = gBS->HandleProtocol(HandleBuffer[i],
+                          &gEfiPartitionInfoProtocolGuid,
+                          (VOID **)&PartInfo);
+      if (EFI_ERROR(Status)) {
+        Print(L"[Debug] Handle %d: No PartitionInfo\n", i);
+        continue;
+      }
+      
+      if (PartInfo->Type == PARTITION_TYPE_GPT) {
+        Print(L"[Debug] Handle %d: GPT Partition found\n", i);
+
+        if (CompareGuid(&gFreeBSDSwapGuid, &PartInfo->Info.Gpt.PartitionTypeGUID)) {
+          Status = gBS->HandleProtocol(HandleBuffer[i],
+                                       &gEfiBlockIoProtocolGuid,
+                                       (VOID **)&BlkIO);
+          if (!EFI_ERROR(Status)) {
+            Print(L"[Activator] Found FreeBSD Swap Partition at Handle %x\n", HandleBuffer[i]);
+            SwapBlkIO = BlkIO;
+            
+            // According to UEFI 2.11 spec, Chapter 7.3.15, caller to 
+            // gBS->LocateHandleBuffer is responsible to free the pool.
+            FreePool(HandleBuffer);
+            break;
+          }
+          else {
+            Print(L"Error: Failed to open BlockIO on Swap Handle: %r\n", Status);
+          }
+        }
+      }
     }
 
-    Status = FileSystem->OpenVolume(FileSystem, &Root);
-
-    if (EFI_ERROR(Status)) {
-      Print(L"Error: OpenVolume failed: %r\n", Status);
+    if (!SwapBlkIO) {
+      Print(L"Error: FreeBSD Swap Partition Not Found\n");
       goto ErrorExit;
     }
 
-    Print(L"[Activator] Open File %s...\n", S4_IMAGE_NAME);
+    // ============================================================
+    // From here, We have located the FreeBSD swap partition BlockIOProtocol.
+    // Now let's read the S4 image from swap partition.
+    // Phase 1: Read the ELF64 header from the S4 image.
+    // Phase 2: Read the program headers from the S4 image, and get the
+    //          filesz and paddr for segments.
+    // Phase 3: Based on the type of the program header, perform different operations:
+    //          - PT_LOAD: Allocate physical memory pages and load the segment into them.
+    //          - PT_FREEBSD_S4_PCB: Like PT_LOAD, allocate a physical memory page,
+    //                               and load the semgnet (PCB payload) into it.
+    //          - PT_FREEBSD_S4_TRAMPOLINE: Only record the trampoline address (paddr)
+    // ============================================================
 
-    Status = Root->Open(
-             Root,
-             &S4ImgFile,
-             S4_IMAGE_NAME,
-             EFI_FILE_MODE_READ,
-             0
-             );
 
-    if (EFI_ERROR(Status)) {
-      Print(L"Error: OpenVolume failed: %r\n", Status);
-      goto ErrorExit;
-    }
+    // Phase 1: Read the ELF64 header from the S4 image.
+    UINT32 MediaId = SwapBlkIO->Media->MediaId;
+    UINT32 BlockSize = SwapBlkIO->Media->BlockSize;
+    EFI_LBA Lba = 0; // XXX: We assume the S4 image is at the beginning of the swap partition
 
-    ReadSize = sizeof(Elf64_Ehdr);
-    Status = S4ImgFile->Read(S4ImgFile, &ReadSize, &Elf64Ehdr);
-    
-    if (EFI_ERROR(Status)) {
-      Print(L"Error: Read ELF64 header failed: %r\n", Status);
+
+    VOID *BlockBuffer = AllocatePool(BlockSize);
+    if (!BlockBuffer)
       goto ErrorExit;
-    }
 
-    Print(L"[Activator] Read File %s and Validate ELF header...\n", 
-          S4_IMAGE_NAME);
-    
+    SwapBlkIO->ReadBlocks(SwapBlkIO,
+                          MediaId,
+                          Lba,
+                          BlockSize,
+                          BlockBuffer);
+
+    CopyMem(&Elf64Ehdr, BlockBuffer, sizeof(Elf64_Ehdr));
+
+    FreePool(BlockBuffer);
+
     // Validate the ELF header of the S4 image
     if (((UINT8 *)&Elf64Ehdr)[EI_MAG0] != ELFMAG0 || 
         ((UINT8 *)&Elf64Ehdr)[EI_MAG1] != ELFMAG1 ||
@@ -121,37 +162,54 @@ UefiMain (
     }
 
 
+    // Phase 2: Read the program headers from the S4 image, and get the
+    //          filesz and paddr for segments.
+
     // Allocate heap space for program headers table
-    PhdrNum = Elf64Ehdr.e_phnum;
-    PhdrEntSize = Elf64Ehdr.e_phentsize;
-    PhdrOffset = Elf64Ehdr.e_phoff;
+    // Note that we need to read extra data if the offset of
+    // the program header table dosen't equal to the block size.
+    UINT16 PhdrNum = Elf64Ehdr.e_phnum;
+    UINT16 PhdrEntSize = Elf64Ehdr.e_phentsize;
+    UINT64 PhdrOffset = Elf64Ehdr.e_phoff;
+
+    UINTN PhdrTableSize = PhdrNum * PhdrEntSize;
+    EFI_LBA StartLba = PhdrOffset / BlockSize;
+    UINTN OffsetInBlock = PhdrOffset % BlockSize;
+    UINTN TotalReadSize = OffsetInBlock + PhdrTableSize;
+    if (TotalReadSize % BlockSize != 0)
+      TotalReadSize = (TotalReadSize / BlockSize + 1) * BlockSize;
+
+    VOID *PhdrTableBlockBuffer = AllocatePool(TotalReadSize);
+    if (!PhdrTableBlockBuffer)
+      goto ErrorExit;
 
-    Elf64PhdrTable = AllocatePool(PhdrNum * PhdrEntSize);
+    SwapBlkIO->ReadBlocks(SwapBlkIO,
+                          MediaId,
+                          StartLba,
+                          TotalReadSize,
+                          PhdrTableBlockBuffer);
+
+
+    Elf64PhdrTable = AllocatePool(PhdrTableSize);
     if (Elf64PhdrTable == NULL) {
       Print(L"Error: Out of memory!\n");
       goto ErrorExit;
     }
 
-    // Program headers table don't necessarily follow the ELF header.
-    // So set the cursor for the sake.
-    Status = S4ImgFile->SetPosition(S4ImgFile, PhdrOffset);
-    if (EFI_ERROR(Status)) {
-      Print(L"Error: Set position %d of file %s failed: %r\n", PhdrOffset, S4_IMAGE_NAME, Status);
-      goto ErrorExit;
-    }
+    CopyMem(Elf64PhdrTable, (UINT8 *)PhdrTableBlockBuffer + OffsetInBlock,
+            sizeof(Elf64_Phdr) * PhdrNum);
+
+    FreePool(PhdrTableBlockBuffer);
 
-    ReadSize = PhdrNum * PhdrEntSize;
-    Status = S4ImgFile->Read(S4ImgFile, &ReadSize, (VOID *)Elf64PhdrTable);
-    if (EFI_ERROR(Status)) {
-      Print(L"Error: Read program headers table (size = %d) failed: %r\n", 
-            PhdrNum * PhdrEntSize, Status);
-      goto ErrorExit;
-    }
 
     Print(L"[Activator] %d program headers in %s. Parse program headers...\n", 
           PhdrNum, S4_IMAGE_NAME);
     
-    // Parse program headers
+    // Phase 3: Based on the type of the program header, perform different operations:
+    //          - PT_LOAD: Allocate physical memory pages and load the segment into them.
+    //          - PT_FREEBSD_S4_PCB: Like PT_LOAD, allocate a physical memory page,
+    //                               and load the semgnet (PCB payload) into it.
+    //          - PT_FREEBSD_S4_TRAMPOLINE: Only record the trampoline address (paddr)
     for (UINT16 Num = 0; Num < PhdrNum; Num++) {
       Elf64_Phdr *CurrentPhdr = &Elf64PhdrTable[Num];
 
@@ -177,25 +235,31 @@ UefiMain (
           }
 
           Print(L"[Activator] Read PT_LOAD segment at file offset %d to %lx...\n", SegmentOffset, PAddr);
-
-          Status = S4ImgFile->SetPosition(S4ImgFile, SegmentOffset);
-          if (EFI_ERROR(Status)) {
-            Print(L"Error: Set position %d of file %s failed: %r\n", SegmentOffset, S4_IMAGE_NAME, Status);
-            goto ErrorExit;
-          }
-
-          Status = S4ImgFile->Read(S4ImgFile, &FileSize, (VOID *)PAddr);
+          
+          // We assume the PT_LOAD segment offset is align with block size
+          EFI_LBA StartLba = SegmentOffset / BlockSize;
+          UINTN ExtraSize = BlockSize - (FileSize % BlockSize);
+          VOID *ExtraStart = (UINT8 *)PAddr + FileSize;
+          UINTN TotalReadSize = FileSize;
+          if (FileSize % BlockSize != 0)
+            TotalReadSize = (TotalReadSize / BlockSize + 1) * BlockSize;
+
+          Status = SwapBlkIO->ReadBlocks(SwapBlkIO,
+                                         MediaId,
+                                         StartLba,
+                                         TotalReadSize,
+                                         (VOID *)PAddr);
           if (EFI_ERROR(Status)) {
             Print(L"Error: Read PT_LOAD segment (size = %d) to %lx failed: %r\n", 
                     FileSize, PAddr, Status);
             goto ErrorExit;
           }
 
+          ZeroMem(ExtraStart, ExtraSize);
+
           Print(L"[Activator] Successfully loaded PT_LOAD segment at file offset %d to %lx...\n", 
                 SegmentOffset, PAddr);
 
-          // TODO: If p_memsz > p_filesz, then we need to zero the extra memory space (may be BSS)
-
           break;
         }
         case PT_FREEBSD_S4_PCB: {
@@ -214,11 +278,26 @@ UefiMain (
             goto ErrorExit;
           }
 
-          Status = S4ImgFile->SetPosition(S4ImgFile, SegmentOffset);
-          if (EFI_ERROR(Status)) goto ErrorExit;
+          // We assume the PT_FREEBSD_S4_PCB segment offset is align with block size
+          EFI_LBA StartLba = SegmentOffset / BlockSize;
+          UINTN ExtraSize = BlockSize - (FileSize % BlockSize);
+          VOID *ExtraStart = (UINT8 *)PcbPAddr + FileSize;
+          UINTN TotalReadSize = FileSize;
+          if (FileSize % BlockSize != 0)
+            TotalReadSize = (TotalReadSize / BlockSize + 1) * BlockSize;
+
+          Status = SwapBlkIO->ReadBlocks(SwapBlkIO,
+                                         MediaId,
+                                         StartLba,
+                                         TotalReadSize,
+                                         (VOID *)PcbPAddr);
+          if (EFI_ERROR(Status)) {
+            Print(L"Error: Read PT_FREEBSD_S4_PCB segment (size = %d) to %lx failed: %r\n", 
+                    FileSize, PcbPAddr, Status);
+            goto ErrorExit;
+          }
 
-          Status = S4ImgFile->Read(S4ImgFile, &FileSize, (VOID *)PcbPAddr);
-          if (EFI_ERROR(Status)) goto ErrorExit;
+          ZeroMem(ExtraStart, ExtraSize);
 
           Print(L"PCB Loaded at: 0x%lx\n", PcbPAddr);
 
@@ -300,11 +379,8 @@ ErrorExit:
     if (Elf64PhdrTable != NULL) {
         FreePool(Elf64PhdrTable);
     }
-    if (S4ImgFile != NULL) {
-        S4ImgFile->Close(S4ImgFile);
-    }
-    if (Root != NULL) {
-        Root->Close(Root);
+    if (HandleBuffer != NULL) {
+        FreePool(HandleBuffer);
     }
 
     return Status;
diff --git a/uefi/S4ActivatorPkg/Application/Activator/Activator.inf b/uefi/S4ActivatorPkg/Application/Activator/Activator.inf
index 1ab8687..9d3a95a 100644
--- a/uefi/S4ActivatorPkg/Application/Activator/Activator.inf
+++ b/uefi/S4ActivatorPkg/Application/Activator/Activator.inf
@@ -19,10 +19,13 @@
   UefiApplicationEntryPoint
   UefiBootServicesTableLib
   MemoryAllocationLib
+  BaseLib
 
 [Protocols]
   gEfiLoadedImageProtocolGuid
   gEfiSimpleFileSystemProtocolGuid
+  gEfiBlockIoProtocolGuid
+  gEfiPartitionInfoProtocolGuid
 
 [Guids]
   gEfiFileInfoGuid
\ No newline at end of file
